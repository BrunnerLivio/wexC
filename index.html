<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>3D Tetris</title>
    <link rel="stylesheet" href="./src/scene.css" />
  </head>
  <body>
    <main id="main" class="scene3d noSelection">
      <div
        class="coords"
        style="--coords-rotate-x: 85; --coords-rotate-y: -15; top: 60cqh"
      >
        <div class="floor"><div class="toplight"></div></div>
        <div class="plane show xz-plane"></div>
        <div class="plane show yz-plane"></div>
        <!--    tetrominos to be added here -->
      </div>
    </main>
    <footer>
      Use mouse or touch to rotate the coords. Arrow keys to move the tetromino.
      Shift + arrow keys to rotate.
    </footer>

    <script type="module">
      import { registerForMouseAndTouch } from "./src/scene.js";
      import { normalize, swapXZ, swapYZ } from "./src/controller.js";
      import {
        shapeI,
        shapeT,
        shape0,
        shapeS,
        shapeZ,
        shapeL,
        shapeF,
      } from "./src/model.js";

      registerForMouseAndTouch(main);

      // initial setup of example shapes (only for experimentation)
      const tetrominos = [];
      const shapes = [shapeI, shapeT, shape0, shapeS, shapeZ, shapeL, shapeF];
      const shapeNames = [
        "shapeI",
        "shapeT",
        "shape0",
        "shapeS",
        "shapeZ",
        "shapeL",
        "shapeF",
      ];
      shapes.forEach((shape, idx) => {
        tetrominos.push({
          position: { x: 0, y: 0, z: 25 },
          shape: shape,
        });
        const parent = document.querySelector(`.scene3d .coords`);
        const viewHtml = `
            <div class="tetromino ${shapeNames[idx]}" data-id="${idx}" style="--tetromino-x: 0;--tetromino-y: 0;--tetromino-z: 0;">
                <div class="box" style="--x: 0;--y: 0;--z: 0;"><div></div><div></div><div></div><div></div><div></div><div></div></div>
                <div class="box" style="--x: 0;--y: 0;--z: 0;"><div></div><div></div><div></div><div></div><div></div><div></div></div>
                <div class="box" style="--x: 0;--y: 0;--z: 0;"><div></div><div></div><div></div><div></div><div></div><div></div></div>
                <div class="box" style="--x: 0;--y: 0;--z: 0;"><div></div><div></div><div></div><div></div><div></div><div></div></div>
            </div>
        `;
        parent.innerHTML += viewHtml;
      });

      const move = (tetro) => {
        const position = tetro.position;
        document
          .querySelector(`[data-id="${tetrominos.indexOf(tetro)}"]`)
          .setAttribute(
            "style",
            `--tetromino-x: ${position.x};
             --tetromino-y: ${position.y};
             --tetromino-z: ${position.z};`
          );
        document
          .querySelector(`[data-id="${tetrominos.indexOf(tetro)}"].ghost`)
          ?.setAttribute(
            "style",
            `--tetromino-x: ${position.x};
             --tetromino-y: ${position.y};
             --tetromino-z: 0;`
          );
      };
      const align = (tetro) => {
        const tetroView = document.querySelector(
          `[data-id="${tetrominos.indexOf(tetro)}"]`
        );
        const ghostView = document.querySelector(
          `[data-id="${tetrominos.indexOf(tetro)}"].ghost`
        );
        tetro.shape = normalize(tetro.shape);
        tetroView.querySelectorAll(".box").forEach((box, idx) => {
          box.setAttribute(
            "style",
            `--x: ${tetro.shape[idx].x};
                 --y: ${tetro.shape[idx].y};
                 --z: ${tetro.shape[idx].z};`
          );
        });
        ghostView?.querySelectorAll(".box").forEach((box, idx) => {
          box.setAttribute(
            "style",
            `--x: ${tetro.shape[idx].x};
                 --y: ${tetro.shape[idx].y};
                 --z: 0;`
          );
        });
      };

      const toppleRoll = (tetro) => (tetro.shape = swapXZ(tetro.shape));
      const topplePitch = (tetro) => (tetro.shape = swapYZ(tetro.shape));
      const rotateYaw = (tetro) => {
        toppleRoll(tetro);
        topplePitch(tetro);
        topplePitch(tetro);
        topplePitch(tetro);
        toppleRoll(tetro);
        toppleRoll(tetro);
        toppleRoll(tetro);
      };

      document.onkeydown = (keyEvt) => {
        keyEvt.preventDefault();
        const tetro = currentTetromino;
        const pos = tetro.position;
        if (keyEvt.shiftKey) {
          switch (keyEvt.key) {
            case "Shift":
              break; // ignore the initial shift signal
            case "ArrowRight":
              rotateYaw(tetro);
              align(tetro);
              break;
            case "ArrowLeft":
              toppleRoll(tetro);
              align(tetro);
              break;
            case "ArrowUp":
              topplePitch(tetro);
              align(tetro);
              break;
            case "ArrowDown":
              pos.z = pos.z - 1;
              move(tetro);
              break;
            default:
              console.warn("unknown key", keyEvt.key);
          }
        } else {
          switch (keyEvt.key) {
            case "ArrowLeft":
              pos.x = pos.x - 1;
              move(tetro);
              break;
            case "ArrowRight":
              pos.x = pos.x + 1;
              move(tetro);
              break;
            case "ArrowUp":
              pos.y = pos.y - 1;
              move(tetro);
              break;
            case "ArrowDown":
              pos.y = pos.y + 1;
              move(tetro);
              break;
            default:
              console.warn("unknown key", keyEvt.key);
          }
        }
      };

      const addGhost = (tetroNum) => {
        const tetroView = document.querySelector(`[data-id="${tetroNum}"]`);
        const clone = tetroView.cloneNode(true);
        clone.classList.add("ghost");
        tetroView.parentElement.appendChild(clone);
      };
      const removeGhost = (tetroNum) => {
        const tetroView = document.querySelector(
          `[data-id="${tetroNum}"].ghost`
        );
        tetroView?.remove();
      };

      // init view
      tetrominos.forEach((tetro) => {
        align(tetro);
        move(tetro);
      });

      let currentTetromino;
      let tetroNum = 7;
      const perTetro = () => {
        removeGhost(tetroNum);
        if (--tetroNum < 0) return;
        currentTetromino = tetrominos[tetroNum];
        addGhost(tetroNum);

        let i = 12;
        currentTetromino.position.z = i;
        const fall = () => {
          if (--i < 0) {
            perTetro();
            return;
          }
          currentTetromino.position.z = i;
          move(currentTetromino);
          setTimeout(fall, 1 * 1000);
        };
        fall();
      };
      perTetro();

      // inspection setting
      // removeGhost(tetroNum);
      // --tetroNum
      // currentTetromino = tetrominos[tetroNum];
      // addGhost(tetroNum);
      // currentTetromino.position.z = 0;
      // move(currentTetromino);
    </script>

    <!-- Fisheye overlay -->

    <style>
      #fisheye {
        position: fixed;
        inset: 0;
        z-index: 999;
        pointer-events: none;
      }
    </style>
    <div id="content"></div>
    <canvas id="fisheye"></canvas>

    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js";

      const canvas = document.getElementById("fisheye");
      const renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);

      const scene = new THREE.Scene();
      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

      const geometry = new THREE.PlaneGeometry(2, 2);
      const material = new THREE.ShaderMaterial({
        transparent: true,
        uniforms: {
          time: { value: 0.0 },
          curvature: { value: 0.8 },
          scanLines: { value: 300.0 },
          scanLineAmplitude: { value: 0.05 },
        },
        vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = vec4(position, 1.0);
      }
    `,
        fragmentShader: `
      uniform float time;
      uniform float curvature;
      uniform float scanLines;
      uniform float scanLineAmplitude;
      varying vec2 vUv;

      void main() {
        // Barrel distortion (fisheye curvature)
        vec2 uv = vUv - 0.5;
        float r = length(uv);
        uv += uv * (r * r * curvature);
        uv += 0.5;

        // Scanlines
        float scan = sin((uv.y + time * 0.1) * scanLines) * scanLineAmplitude;

        vec3 color = vec3(0.9, 1.0, 0.9);
        color -= scan;
        gl_FragColor = vec4(color, 0.25);
      }
    `,
      });

      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      function onResize() {
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      window.addEventListener("resize", onResize);

      function animate(t) {
        material.uniforms.time.value = t * 0.001;
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      animate();
    </script>
  </body>
</html>
